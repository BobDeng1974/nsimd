<!--

Copyright (c) 2019 Agenium Scale

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

-->

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>NSIMD documentation</title>
    <style type="text/css">
      body {
        /*margin:40px auto;*/
        margin:10px auto;
        /*max-width:650px;*/
        max-width:800px;
        /*line-height:1.6;*/
        line-height:1.4;
        /*font-size:18px;*/
        color:#444;
        padding:0 10px
      }
      h1,h2,h3 {
        line-height:1.2
      }
      table,th, td {
        border: 1px solid gray;
        border-collapse : collapse;
        padding: 1px 3px;
      }
    </style>
    <!-- https://www.mathjax.org/#gettingstarted -->
    <script src="assets/polyfill.min.js"></script>
    <script id="MathJax-script" async src="assets/tex-mml-chtml.js"></script>
    <!-- Highlight.js -->
    <link rel="stylesheet" href= "assets/highlight.js.default.min.css">
    <script src="assets/highlight.min.js"></script>
    <script src="assets/cpp.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
<body>

<center>
  <img src="img/logo.svg"><br>
  <br>
  <a href="index.html">Index</a> |
  <a href="quick_start.html">Quick Start</a> |
  <a href="tutorials.html">Tutorials</a> |
  <a href="faq.html">FAQ</a> |
  <a href="contribute.html">Contribute</a> |
  <a href="overview.html">API overview</a> |
  <a href="api.html">API reference</a>
</center>
<h1>Intermediate Tutorial: SIMD Branching</h1>
<p>In this tutorial we will examine how to handle branches in SIMD programs.</p>
<h2>Branching</h2>
<p>One of the fundamental principles of SIMD programming is that the same operation
must be performed on each element of the SIMD vector. At first glance, this
means that vectorized programs do not support conditional statements, however
this is not true. Let&apos;s take a common image processing operation known as
thresholding as a counter example. Thresholding is an operation to separate a
digital image into its background and foreground pixels. Any pixel whose value
is less than the chosen threshold is considered to be a background pixel and
conversely, any pixel whose value is greater or equal to the threshold is
considered to be a foreground pixel. The scalar version of this algorithm is
simply:</p>
<pre class="C++"><code>for (size_t i = 0; i &lt; img.size(); ++i) {
  if (img[i] &lt; threshold_value) {
    img[i] = 0;
  } else {
    img[i] = 255;
  }
}</code></pre>

<p>Here we have a very clear branch in the code. How can we vectorize this loop?</p>
<h2>Logical SIMD Type</h2>
<p>In this example, we need a new type, <code>nsimd::packl&lt;T&gt;</code>, which is an abstraction
for the equivalent of a <code>bool</code> on a particular architecture. Therefore, a
<code>nsimd::packl&lt;T&gt;</code> a pack of <code>bool</code>. This abstraction is necessary to ensure that
any code written using <code>nsimd</code> is portable due to the differences between how
various processors handle operations requiring logical values.</p>
<p>The return type of a comparison operation in C++ is a <code>bool</code>, therefore the
return type of a comparison operation with <code>nsimd::pack&lt;T&gt;</code> is a
<code>nsimd::packl&lt;T&gt;</code>. This <code>nsimd::packl&lt;T&gt;</code> is then used to generate a SIMD vector
of <code>0</code> and/or <code>255</code> using the function <code>nsimd::if_else1</code>. All that&apos;s left to do
now is to store this vector in its correct location in memory.</p>
<pre class="C++"><code>  nsimd::pack&lt;uint8_t&gt; pack_threshold_value(threshold_value);
  nsimd::pack&lt;uint8_t&gt; pack_0(0);
  nsimd::pack&lt;uint8_t&gt; pack_255(255);

  size_t i;
  size_t len = size_t(nsimd::len(nsimd::pack&lt;uint8_t&gt;()));
  for (i = 0; i + len &lt; img.size(); i += len) {
    nsimd::pack&lt;uint8_t&gt; pack = nsimd::loada&lt;nsimd::pack&lt;uint8_t&gt; &gt;(&amp;img[i]);
    nsimd::packl&lt;uint8_t&gt; pack_logical = pack &lt; pack_threshold_value;
    // Possible values:
    // { 1, 0, 0, 1 } = { 75, 180, 152, 40, } &lt; { 128, 128, 128, 128 }
    pack = nsimd::if_else1(pack_logical, pack_0, pack_255);
    // Possible values:
    // { 255, 0, 0, 255 } = if_else1({ 0, 0, 0, 0, }, { 255, 255, 255, 255 })
    nsimd::storea(&amp;img[i], pack);
  }

  for (; i &lt; img.size(); ++i) {
    if (img[i] &lt; threshold_value) {
      img[i] = 0;
    } else {
      img[i] = 255;
    }
  }</code></pre>

<p>Download full source code:</p>
<ul>
<li><p><a href="../src/threshold.cpp">threshold.cpp</a></p></li>
</ul>
<p>If you use
<a href="https://en.wikipedia.org/wiki/File:Pavlovsk_Railing_of_bridge_Yellow_palace_Winter.jpg">this image</a>
as input data:<br>
<img src="img/640px-Pavlovsk_Railing_of_bridge_Yellow_palace_Winter.jpg" alt="640px-Pavlovsk_Railing_of_bridge_Yellow_palace_Winter" /></p>
<p>You should obtain:<br>
<img src="img/threshold_nsimd.jpg" alt="threshold_nsimd" /></p>
  </body>
</html>
